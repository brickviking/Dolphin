"Filed out from Dolphin Smalltalk"!

Core.Tests.DolphinTest subclass: #'Core.Tests.DelayTest'
	instanceVariableNames: 'delay startTime'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Core.Tests.DelayTest guid: (Core.GUID fromString: '{0b7c6875-1051-4b80-b137-cd1c02754bcd}')!
Core.Tests.DelayTest comment: ''!
!Core.Tests.DelayTest categoriesForClass!Unclassified! !
!Core.Tests.DelayTest methodsFor!

expectDelay: expectedDuration for: nowMicroseconds
	| elapsed delta |
	elapsed := (nowMicroseconds - startTime) microseconds.
	delta := elapsed - expectedDuration.
	"Although a Delay could end up waiting much longer than the expected duration,
	e.g. if the CPU is very busy, this should happen only rarely, and we do not want
	to tolerate it if it happens all the time as that would indicate an actual bug."
	self assert: (delta between: -1 milliseconds and: 5 milliseconds)
		description: 
			[String smalltalkWriteStream
				nextPutAll: 'Expected delay of ';
				display: expectedDuration;
				nextPutAll: ' got ';
				display: elapsed;
				contents]!

setUp
	super setUp.
	Delay timerResolution: 1 milliseconds set: true!

tearDown
	Delay timerResolution: 1 milliseconds set: false.
	super tearDown!

testBasicWait
	| endTime |
	delay := Delay forMilliseconds: 20.
	startTime := Time microsecondClockValue.
	delay wait.
	endTime := Time microsecondClockValue.
	self expectDelay: delay duration for: endTime!

testCancel
	| proc endTime |
	delay := Delay forMilliseconds: 20.
	proc := 
			[delay wait.
			endTime := Time microsecondClockValue] forkAt: Processor userInterruptPriority.
	
	[delay cancel.
	self deny: Delay.Current identicalTo: delay.
	self deny: (Delay.Pending includes: delay).
	(Delay forMilliseconds: 30) wait.
	self assertIsNil: endTime.
	self assert: proc isWaiting]
			ensure: [proc terminate]!

testCancelWithOtherShorterDelay
	[(Delay forMilliseconds: 10) wait] forkAt: Processor userInterruptPriority.
	self testCancel!

testSchedulingMultipleDelays
	| endTime delay2 |
	delay := Delay forMilliseconds: 20.
	delay2 := Delay forMilliseconds: 30.
	
	[startTime := Time microsecondClockValue.
	delay wait.
	endTime := Time microsecondClockValue]
			forkAt: Processor userInterruptPriority.
	delay2 wait.
	self expectDelay: delay duration for: endTime.
	self expectDelay: delay2 duration for: Time microsecondClockValue!

testSchedulingMultipleDelaysLongerFirst
	| endTime delay2 delay3 endTime2 |
	delay := Delay forMilliseconds: 30.
	delay2 := Delay forMilliseconds: 20.
	delay3 := Delay forMilliseconds: 20.
	
	[startTime := Time microsecondClockValue.
	delay wait.
	endTime := Time microsecondClockValue]
			forkAt: Processor userInterruptPriority.
	"Wait for a shorter period than the other process"
	delay2 wait.
	"We should have waited for the correct time, other proc is still waiting"
	self expectDelay: 20 milliseconds for: Time microsecondClockValue.
	self assertIsNil: endTime.
	"Now wait long enough for it to be done"
	delay3 wait.
	endTime2 := Time microsecondClockValue.
	self expectDelay: delay duration for: endTime.
	self expectDelay: delay2 duration + delay3 duration for: endTime2!

testSignal
	| endTime delay2 |
	delay := Delay forMilliseconds: 20.
	delay2 := Delay forMilliseconds: 10.
	
	[startTime := Time microsecondClockValue.
	delay wait.
	endTime := Time microsecondClockValue]
			forkAt: Processor userInterruptPriority.
	delay2 wait.
	delay signal.
	self expectDelay: delay2 duration for: endTime!

testSimultaneousWaitAndSignal
	| waitError signalError signalFinished endTime |
	delay := Delay forMilliseconds: 20.
	signalFinished := false.
	Delay.AccessProtect wait.	"Ensure that the Delay wait will be blocked"
	startTime := Time microsecondClockValue.
	
	[[delay wait] on: Error do: [:ex | waitError := ex].
	endTime := Time microsecondClockValue] fork.	"Delay>>wait will calc a resumption time, then block"
	
	[[delay signal] on: Error do: [:ex | signalError := ex].
	signalFinished := true]
			forkAt: Processor userInterruptPriority.	"Will block on AccessProtect in #cancel too, but higher priority"
	Delay.AccessProtect signal.	"Allow the bug to unfold"
	OS.Kernel32 sleep: 10.	"Wait for both processes above to finish, without using the Delay mechanism"
	self expectDelay: 0 milliseconds for: endTime.	"Process should not have actually waited on the delay"
	self assertIsNil: waitError.
	self assert: signalFinished.
	self assertIsNil: signalError!

testSimultaneousWaitAndSignalWithOtherLongerDelay
	[(Delay forMilliseconds: 25) wait] forkAt: Processor userInterruptPriority.
	self testSimultaneousWaitAndSignal!

testSimultaneousWaitAndSignalWithOtherShorterDelay
	[(Delay forMilliseconds: 15) wait] forkAt: Processor userInterruptPriority.
	self testSimultaneousWaitAndSignal! !
!Core.Tests.DelayTest categoriesFor: #expectDelay:for:!helpers!private! !
!Core.Tests.DelayTest categoriesFor: #setUp!private!running! !
!Core.Tests.DelayTest categoriesFor: #tearDown!private!running! !
!Core.Tests.DelayTest categoriesFor: #testBasicWait!public!unit tests! !
!Core.Tests.DelayTest categoriesFor: #testCancel!public!unit tests! !
!Core.Tests.DelayTest categoriesFor: #testCancelWithOtherShorterDelay!public!unit tests! !
!Core.Tests.DelayTest categoriesFor: #testSchedulingMultipleDelays!public!unit tests! !
!Core.Tests.DelayTest categoriesFor: #testSchedulingMultipleDelaysLongerFirst!public!unit tests! !
!Core.Tests.DelayTest categoriesFor: #testSignal!public!unit tests! !
!Core.Tests.DelayTest categoriesFor: #testSimultaneousWaitAndSignal!public!unit tests! !
!Core.Tests.DelayTest categoriesFor: #testSimultaneousWaitAndSignalWithOtherLongerDelay!public!unit tests! !
!Core.Tests.DelayTest categoriesFor: #testSimultaneousWaitAndSignalWithOtherShorterDelay!public!unit tests! !

