<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../helpproject.xsl" ?>
<topic template="Default" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../helpproject.xsd">
  <title translate="true">To Overlap or Not to Overlap</title>
  <keywords>
    <keyword translate="true">To Overlap or Not to Overlap</keyword>
  </keywords>
  <body>
    <header>
      <para styleclass="Heading1"><text styleclass="Heading1" translate="true">To Overlap or Not to Overlap</text></para>
    </header>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">It is tempting to overlap all external calls, but there are at least five reasons why one shouldn&apos;t (or can&apos;t) do this:</text></para>
    <list id="2" type="ol" listtype="decimal" formatstring="&#37;&#48;&#58;&#115;&#46;" levelreset="false" legalstyle="false" startfrom="1" styleclass="Normal" style="margin-left:24px; font-family:Arial; font-size:9pt; color:#000000;">
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Overhead</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Virtual/COM Calls</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Idle panic</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Multi-threaded callbacks</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Unexpected multi-processing</text></li>
    </list>
    <para styleclass="Normal Head"><text styleclass="Normal Head" translate="true">Overlapped Call Overhead</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Overlapped calls do have some overhead relative to standard external call. This is because of context switch time; at least two thread context switches must be made for a threaded call to complete, typically four. These are necessary for the call to be initiated, and then for notification when the call completes and completion of the call in synchronization with the main VM thread. Bearing this in mind, the overhead is surprisingly low, with the simplest overlapped calls having only about 40% overhead. This is not likely to be an issue for longer running calls where the overhead of the call itself is insignificant in relation to the duration of the call, but would be for calls such as the CRT </text><text styleclass="Class Name" translate="true">sin</text><text styleclass="Normal" translate="true">() function.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">When the first overlapped call is made from a Smalltalk Process object there is significant additional overhead, because it requires allocation and initialisation of an operating system thread. This should only be an issue if your application starts a lot of short lived Processes that only perform one or two overlapped calls. </text></para>
    <para styleclass="Normal Head"><text styleclass="Normal Head" translate="true">Virtual/COM Calls</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">C++ virtual function calls (the means by which COM call-outs are implemented) cannot be overlapped. This may change in a future release, but currently the compiler does not allow both &apos;virtual&apos; and &apos;overlap&apos; attributes to be applied to the same function call, and there is no primitive support for overlapped virtual calls either.</text></para>
    <para styleclass="Normal Head"><text styleclass="Normal Head" translate="true">Idle Panic</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">&quot;Idle Panic&quot; is that state the VM enters when it finds that it has no processes ready to run. Under normal conditions the Idle process is always ready to run, and prevents the VM panicking about what to do next by putting the VM thread to sleep (it calls one of the </text><text styleclass="Class Name" translate="true">MsgWaitForMultipleObjects</text><text styleclass="Normal" translate="true">() family of functions, depending on the host OS). If any of the external calls the idle process makes are modified to be overlapped, or the idle loop itself is modified to perform other overlapped calls, then the idle </text><text styleclass="Class Name" translate="true">Process</text><text styleclass="Normal" translate="true"> will be blocked, and enter a wait state. At this point if no other process is ready the VM will send an &quot;idle panic&quot; interrupt into the image, the default handling of which (see </text><text styleclass="Class Name" translate="true">InputState&gt;&gt;idlePanic</text><text styleclass="Normal" translate="true">) is to terminate the existing idle process and start a new one. If the new idle process persists in making overlapped calls, then the system will start to thrash, continuously starting and terminating idle processes.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">This situation can easily be avoided by not modifying the idle loop, and by not marking any of the functions called by that loop as overlapped.</text></para>
    <para styleclass="Normal Head"><text styleclass="Normal Head" translate="true">Multi-threaded Callbacks</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Some functions generate immediate callbacks into the image, either explicitly as </text><link displaytype="text" defaultstyle="true" type="topiclink" href="externalcallbacks" styleclass="Normal" translate="true">External Callbacks</link><text styleclass="Normal" translate="true">, or implicitly through the Windows message queue (e.g. </text><text styleclass="Class Name" translate="true">DestroyWindow</text><text styleclass="Normal" translate="true">). The latter are always synchronised and directed to the VMs main thread by Windows, but the former may generated callbacks on other threads. The VM intercepts these callbacks and has to redirect them to the main VM thread so that they can be processed safely in the same manner as Windows, i.e. by synchronising them through the message queue. In order that such callbacks can be processed, the message queue has to be serviced, which requires that the main UI process return to the message loop. It should be apparent that this will cause a deadlock in the case of such synchronous callbacks, because main UI process is blocked waiting for the original function to return, and therefore cannot service the message queue.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">By way of example, if we mark </text><text styleclass="Class Name" translate="true">GDILibrary&gt;&gt;enumFonts: lpFaceName: lpFontFunc:lParam: </text><text styleclass="Normal" translate="true">as overlapped, and evaluate an expression such as:</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">Canvas forDesktop fonts: &apos;Arial&apos; do: [</text></para>
    <para styleclass="Code Example"><tab /><text styleclass="Code Example" translate="true">:lplf :lptm :dwType| Transcript print: lplf; cr]</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Then Dolphin will simply lock up, although it can be broken into with </text><text styleclass="Menu Command" translate="true">Ctrl+Break</text><text styleclass="Normal" translate="true">.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">To avoid this problem, do </text><text styleclass="Normal" style="font-weight:bold;" translate="true">not</text><text styleclass="Normal" translate="true"> overlap calls that generate synchronous callbacks.</text></para>
    <para styleclass="Normal Head"><text styleclass="Normal Head" translate="true">Unexpected Multi-processing</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Smalltalk was originally designed to be a co-operative multithreaded system, rather than a pre-emptive multi-threading system. Smalltalk </text><text styleclass="Class Name" translate="true">Processes</text><text styleclass="Normal" translate="true"> can be pre-empted by higher priority processes, but not by </text><text styleclass="Class Name" translate="true">Processes</text><text styleclass="Normal" translate="true"> at the same or lower priority, no matter how long they run without yielding. This assumption permeates code in certain Smalltalk libraries, although we have addressed this in the Dolphin class library and indeed the Dolphin VM does multi-task more aggressively than normal Smalltalk VMs. In particular it may switch between processes at the same priority when any process synchronisation primitives is executed, regardless of whether that primitive would block the active </text><text styleclass="Normal" style="font-style:italic;" translate="true">Process</text><text styleclass="Normal" translate="true">.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The only code in the Dolphin library that expects to run to completion to the exclusion of all other processes is the startup code, which is run at a high priority. This special case is necessary allow the system to reach a stable state before normal application processing begins. If the startup code is interrupted, then the system might not be in a stable state when other processes start to run.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Recall that issuing an overlapped call automatically blocks the calling process and allows other processes to run. Consequently one must not issue any overlapped external calls from </text><text styleclass="Class Name" translate="true">SessionManager</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">startup code, i.e. not in any of the primary, secondary or tertiary startup phases (see the &apos;operations-startup&apos; category of methods under </text><text styleclass="Class Name" translate="true">SessionManager</text><text styleclass="Normal" translate="true">). Once the </text><text styleclass="Class Name" translate="true">#main</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">method has been entered, it is safe to use overlapped calls.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">It should be noted that normal </text><text styleclass="Class Name" translate="true">MessageBoxes</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">are created by an overlapped call, and so if these must be used during startup then either delay the </text><text styleclass="Class Name" translate="true">MessageBox&apos;s</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">creation until </text><text styleclass="Class Name" translate="true">#main</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">is activated, or mark the </text><text styleclass="Class Name" translate="true">MessageBox</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">as </text><text styleclass="Class Name" translate="true">#taskModal</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">(in which case it will be opened using a normal, non-overlapped, external call).</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">If overlapped calls are inadvertently used during session startup, then one&apos;s deployed applications may exhibit any of the following symptoms:</text></para>
    <list id="3" type="ul" listtype="bullet" formatstring="&#183;" format-charset="SYMBOL_CHARSET" levelreset="true" legalstyle="false" startfrom="1" styleclass="Normal" style="margin-left:24px; font-family:Symbol; font-size:9pt; color:#000000;">
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Errors due to uninitialized subsystems</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Startup code running twice</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Applications windows failing to open, or conversely multiple copies being opened.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Failure to shut down.</text></li>
    </list>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The easiest way to avoid all these problems is to do all application specific session startup, for example opening the main application window, in the </text><text styleclass="Class Name" translate="true">#main</text><text styleclass="Normal" translate="true"> method.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Session startup processing is a special case, and one should try and avoid creating other cases where blocking a process due to issuing an overlapped external call will result in instability or incorrect operation. In other words don&apos;t ever assume that non-interruptible behaviour can be guaranteed, even by boosting process priority or turning off interrupts, but instead use process synchronisation objects such as </text><text styleclass="Class Name" translate="true">Mutex</text><text styleclass="Normal" translate="true"> or </text><text styleclass="Class Name" translate="true">Semaphore</text><text styleclass="Normal" translate="true"> to protect critical sections.</text></para>
  </body>
</topic>
