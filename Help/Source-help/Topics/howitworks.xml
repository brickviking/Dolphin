<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../helpproject.xsl" ?>
<topic template="Default" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../helpproject.xsd">
  <title translate="true">How it works</title>
  <keywords>
    <keyword translate="true">How it works</keyword>
  </keywords>
  <body>
    <header>
      <para styleclass="Heading1"><text styleclass="Heading1" translate="true">How it works</text></para>
    </header>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The exception handling system in Dolphin is written entirely in Smalltalk (though it does rely on the VM&apos;s special support for unwind blocks), and is a good example of the systems reflective capabilities - because even the execution state of a program is accessible to that program (as objects of course), it is possible for a program to modify its execution state, and this is precisely what the exception handling system does.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">It is not necessary to understand precisely how exceptions work in Dolphin, but an overview may be helpful in when using them, and will gives some idea of the overhead involved. To learn more about the implementation of exceptions in Dolphin, browse through the source code in </text><text styleclass="Class Name" translate="true">Exception</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">(and its immediate subclasses), and </text><text styleclass="Class Name" translate="true">ExceptionHandlerAbstract</text><text styleclass="Normal" translate="true"> (</text><text styleclass="Normal" translate="true">and its subclasses).</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Each Dolphin process maintains a &apos;stack&apos; of exception contexts, with a new one being instantiated and pushed on the stack for each </text><text styleclass="Normal" translate="true">#on:do:</text><text styleclass="Normal" translate="true">. The exception context includes all relevant details from the </text><text styleclass="Class Name" translate="true">#on:do</text><text styleclass="Normal" translate="true">:</text><text styleclass="Normal" translate="true"> message, and from the execution state at the time of the message. As </text><text styleclass="Class Name" translate="true">#on:do</text><text styleclass="Normal" translate="true">:</text><text styleclass="Normal" translate="true">&apos;s exit, the corresponding exception context is popped from the stack.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Note that establishing an </text><text styleclass="Class Name" translate="true">#on:do</text><text styleclass="Normal" translate="true">:</text><text styleclass="Normal" translate="true"> handler carries the overhead of instantiating an exception context. A similar overhead is present in the implementation of the native &quot;structured exceptions&quot; on Win32 platforms, for example in C++, except that the compiler hides the implementation details. This overhead is incurred regardless of whether any exceptions are actually raised.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">An exception is raised by instantiating a suitable instance of an exception class with pertinent details relating to the exceptional condition (e.g. in the case of a </text><text styleclass="Class Name" translate="true">BoundsError</text><text styleclass="Normal" translate="true">, the receiver and the index which is out of bounds), and sending it the </text><text styleclass="Class Name" translate="true">#signal</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">message, though frequently this is wrapped inside a shortcut instance creation method provided by the exception class.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">When an exception is raised in a </text><text styleclass="Class Name" translate="true">Process</text><text styleclass="Normal" translate="true">, execution is effectively suspended, though only in the same way that any method execution is suspended when it sends a message and another method is invoked, and the exception system begins a search through the stack of exception contexts. At each level, the exception context is queried to see if it is suitable for handling the raised exception. Typically this matching operation is simply an </text><text styleclass="Class Name" translate="true">#isKindOf</text><text styleclass="Normal" translate="true">:</text><text styleclass="Normal" translate="true"> test to see if the class of the raised exception is the same kind as the class of exception specified by the handler, but more sophisticated matching is possible (for example against a set of </text><text styleclass="Class Name" translate="true">Exception</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">classes). The stack will tend to be only a few contexts deep, so this is a very fast search, but the overhead relative to the alternative of explicitly checking for an error is high, although it is only incurred if the exceptional case.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">If an exception context is located which wants to handle the exception, then the corresponding handler block is evaluated with the exception instance as the argument. The handler block can take any of the handler actions, with these mostly being implemented by evaluating blocks containing ^-returns that were captured at appropriate points to allow for resumption of execution at the desired point.</text></para>
  </body>
</topic>
