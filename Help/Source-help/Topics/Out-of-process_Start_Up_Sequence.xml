<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../helpproject.xsl" ?>
<topic template="Default" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../helpproject.xsd">
  <title translate="true">Out-of-process Start Up Sequence</title>
  <body>
    <header>
      <para styleclass="Heading1"><text styleclass="Heading1" translate="true">Out-of-process Start Up Sequence</text></para>
    </header>
    <list id="1" type="ol" listtype="decimal" formatstring="&#37;&#48;&#58;&#115;&#46;" levelreset="false" legalstyle="false" startfrom="1" styleclass="Normal" style="font-family:Arial; font-size:9pt; color:#000000;">
      <li styleclass="Normal"><text styleclass="Normal" translate="true">Client calls </text><text styleclass="Class Name" translate="true">CoCreateInstance</text><text styleclass="Normal" translate="true">() (or I</text><text styleclass="Class Name" translate="true">ClassFactory::CreateInstance</text><text styleclass="Normal" translate="true">()) with </text><text styleclass="Class Name" translate="true">CLSCTX_LOCAL_SERVER</text><text styleclass="Normal" translate="true"> context flag.</text></li>
      <li styleclass="Normal"><text styleclass="Normal" translate="true">COM locates looks up component</text><text styleclass="Normal" translate="true">’</text><text styleclass="Normal" translate="true">s </text><text styleclass="Class Name" translate="true">CLSID</text><text styleclass="Normal" translate="true"> entry in the registry and uses its </text><text styleclass="Class Name" translate="true">LocalServer32</text><text styleclass="Normal" translate="true"> sub-key to find the command line to start the server.</text></li>
      <li styleclass="Normal"><text styleclass="Normal" translate="true">COM launches the .EXE using the command line from the registry (which must include the correct image path), appending the /</text><text styleclass="Class Name" translate="true">Embedding</text><text styleclass="Normal" translate="true"> command line flag. It then waits for the new process to register the required class factory, or for a timeout. </text></li>
      <li styleclass="Normal"><text styleclass="Program Feature" translate="true">Dolphin.exe</text><text styleclass="Normal" translate="true"> starts up, creates a VM, and asks it to load the image specified on the command line. If this image cannot be found, then the VM will display the usual message box, and the original call will eventually timeout in the client with an appropriate error code.</text></li>
      <li styleclass="Normal"><text styleclass="Normal" translate="true">Assuming the image is found and loaded, then during start-up processing the </text><text styleclass="Class Name" translate="true">SessionManager</text><text styleclass="Normal" translate="true"> processes the /</text><text styleclass="Class Name" translate="true">Embedding</text><text styleclass="Normal" translate="true"> flag and starts up in headless mode; no windows will be opened, although the splash screen will be shown unless suppressed by the /</text><text styleclass="Class Name" translate="true">nosplash</text><text styleclass="Normal" translate="true"> command line flag.</text></li>
      <li styleclass="Normal"><text styleclass="Class Name" translate="true">COMClassFactory</text><text styleclass="Normal" translate="true"> registers (using the </text><text styleclass="Class Name" translate="true">CoRegisterClassObject</text><text styleclass="Normal" translate="true"> API call) </text><text styleclass="Class Name" translate="true">IUnknown</text><text styleclass="Normal" translate="true">s on instances of itself for all COM server object classes for which a class factory has previously been registered.</text></li>
      <li styleclass="Normal"><text styleclass="Normal" translate="true">COM (or the client directly) calls I</text><text styleclass="Class Name" translate="true">ClassFactory::CreateInstance</text><text styleclass="Normal" translate="true">() on the appropriate class object that the server has just registered. This results in a call to </text><text styleclass="Class Name" translate="true">COMClassFactory&gt;&gt;CreateInstance:riid:ppvObject:</text><text styleclass="Normal" translate="true"> which creates a new instance of the Dolphin class that implements the component, and queries off the desired interface.</text></li>
      <li styleclass="Normal"><text styleclass="Normal" translate="true">If no errors have occurred the interface pointer is returned to the client. In order to return the interface COM must “marshal” the interface pointer into the client</text><text styleclass="Normal" translate="true">’</text><text styleclass="Normal" translate="true">s process, so failure is still possible, even at this late stage, if marshalling code is not available for the interface.</text></li>
      <li styleclass="Normal"><text styleclass="Normal" translate="true">Assuming there were no errors, and the interface could be marshalled, the client should now be in possession of an interface pointer of the type it requested onto an instance of the component it requested. The client can now use this interface pointer to directly invoke the methods of COM object, with COM marshalling the parameters and return values between the separate client and server processes.</text></li>
    </list>
  </body>
</topic>
