<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../helpproject.xsl" ?>
<topic template="Default" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../helpproject.xsd">
  <title translate="true">External Memory Management</title>
  <keywords>
    <keyword translate="true">External Memory Management</keyword>
  </keywords>
  <body>
    <header>
      <para styleclass="Heading1"><text styleclass="Heading1" translate="true">External Memory Management</text></para>
    </header>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">On occasion it is necessary to take responsibility for managing the lifetime of objects allocated externally. Such external resources are not, by default, automatically managed by the Dolphin garbage collector, and explicit freeing is required. However, managing the lifetime of such objects can automatically initiated by the garbage collector if we make use of </text><link displaytype="text" defaultstyle="true" type="topiclink" href="weakcollection" styleclass="Normal" translate="true">Weak Collections</link><text styleclass="Normal" translate="true"> and </text><link displaytype="text" defaultstyle="true" type="topiclink" href="finalization" styleclass="Normal" translate="true">Finalization</link><text styleclass="Normal" translate="true">.</text></para>
    <para styleclass="Normal Head"><text styleclass="Normal Head" translate="true">ExternalAddress</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Usually external memory blocks (e.g. containing externally allocated structures) are referenced via instances of </text><text styleclass="Class Name" translate="true">ExternalAddress</text><text styleclass="Normal" translate="true">.</text></para>
    <para styleclass="Normal"><text styleclass="Class Name" translate="true">ExternalAddress</text><text styleclass="Normal" translate="true"> is marked as a class of &quot;indirection&quot; objects, which means that the VM&apos;s external call primitives will treat it differently to normal byte objects when used as an argument to an external method, depending on the parameter type. For example, when passed to </text><text styleclass="Class Name" translate="true">lpvoid</text><text styleclass="Normal" translate="true"> parameters, the contents of the </text><text styleclass="Class Name" translate="true">ExternalAddress</text><text styleclass="Normal" translate="true">, as opposed to its own address, will be passed, i.e. the </text><text styleclass="Class Name" translate="true">ExternalAddress</text><text styleclass="Normal" translate="true"> is automatically dereferenced. See </text><link displaytype="text" defaultstyle="true" type="topiclink" href="parametertypes.validationandconversion" styleclass="Normal" translate="true">Parameter Types, Validation and Conversion</link><text styleclass="Normal" translate="true"> for further details.</text></para>
    <para styleclass="Normal"><text styleclass="Class Name" translate="true">Integers</text><text styleclass="Normal" translate="true"> (small and 4-byte large) are also treated as indirection objects, and so can often be used interchangeably with </text><text styleclass="Class Name" translate="true">ExternalAddresses</text><text styleclass="Normal" translate="true">. </text><text styleclass="Class Name" translate="true">SmallIntegers</text><text styleclass="Normal" translate="true"> are not, however, mutable and cannot be passed to </text><text styleclass="Class Name" translate="true">lppvoid</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">parameter types.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The address of the contents of byte-object can be retried by sending it the </text><text styleclass="Class Name" translate="true">#yourAddress</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">message. The answer will be an </text><text styleclass="Normal" translate="true">Integer</text><text styleclass="Normal" translate="true">,</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">usually small</text><text styleclass="Normal" translate="true">, </text><text styleclass="Normal" translate="true">which can be converted to an </text><text styleclass="Class Name" translate="true">ExternalAddress</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">by sending it the </text><text styleclass="Class Name" translate="true">#asExternalAddress</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">message.</text></para>
    <para styleclass="Normal Head"><text styleclass="Normal Head" translate="true">ExternalMemory</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">External memory blocks that are known to have been allocated from the standard Win32 process heap are best referenced via instances of the </text><text styleclass="Class Name" translate="true">ExternalAddress</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">subclass </text><text styleclass="Class Name" translate="true">ExternalMemory</text><text styleclass="Normal" translate="true">, which uses finalization to automatically free the memory block back to the heap when the Smalltalk object is garbage collected. An </text><text styleclass="Class Name" translate="true">ExternalStructure</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">can be created on a memory block referenced via an </text><text styleclass="Class Name" translate="true">ExternalMemory</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">instance by sending the appropriate subclass the </text><text styleclass="Class Name" translate="true">#fromAddress</text><text styleclass="Normal" translate="true">:</text><text styleclass="Normal" translate="true"> instantiator with the </text><text styleclass="Class Name" translate="true">ExternalMemory</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">as the argument.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">One can construct an empty </text><text styleclass="Class Name" translate="true">ExternalStructure</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">sub-instance ready to point at an externally allocated block (which will presumably be filled in by some external function call) by sending the message </text><text styleclass="Class Name" translate="true">#newHeapPointer</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">to the appropriate </text><text styleclass="Class Name" translate="true">ExternalStructure</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">subclass.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Certain add-in packages (such as OLE COM) add </text><text styleclass="Class Name" translate="true">ExternalMemory</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">subclasses for managing external memory blocks from heaps other than the default process heap (e.g. </text><text styleclass="Class Name" translate="true">COMTaskMemory</text><text styleclass="Normal" translate="true">), and one can easily add your own subclasses if required.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The various subclasses of </text><text styleclass="Class Name" translate="true">ExternalMemory</text><text styleclass="Normal" translate="true"> implement a class side protocol for allocating and freeing dynamic memory from various external heaps. In fact they all implement the COM interface, </text><text styleclass="Class Name" translate="true">IMalloc</text><text styleclass="Normal" translate="true">, which is an object-oriented abstract for a heap.</text></para>
    <para styleclass="Normal Head"><text styleclass="Normal Head" translate="true">ExternalHandle</text></para>
    <para styleclass="Normal"><text styleclass="Class Name" translate="true">ExternalHandle</text><text styleclass="Normal" translate="true"> is a special class of object used to represent opaque 32-bit handles to external objects and structures. These are sometimes pointers to objects or structures with a private format, and sometimes some other form of integer handle from which allocator of the handle can uniquely identify a particular resource. </text><text styleclass="Class Name" translate="true">ExternalHandles</text><text styleclass="Normal" translate="true"> should always be used to refer to external resources which are only valid for the lifetime of a running image, but which will no longer be valid on image restart. As of Dolphin 4.0, </text><text styleclass="Class Name" translate="true">ExternalHandles</text><text styleclass="Normal" translate="true"> are automatically set to null (zero) by the VM at image load time. This removes the need to add special start-up handling to do the same in the image, speeding start-up and making it more reliable.</text></para>
  </body>
</topic>
