<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../helpproject.xsl" ?>
<topic template="Default" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../helpproject.xsd">
  <title translate="true">And finally??</title>
  <keywords>
    <keyword translate="true">And finally??</keyword>
  </keywords>
  <body>
    <header>
      <para styleclass="Heading1"><text styleclass="Heading1" translate="true">And finally??</text></para>
    </header>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Generally we don&apos;t want to be bothered about the expiry of an object, we let the VM deal with cleaning up all the old rubbish. Finalization is for those cases where we do want, or need, to get involved.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Dolphin provides a mechanism by which objects are informed when they are about to expire. How objects respond to this notification, i.e. how they finalize themselves, is their own business - </text><link displaytype="text" defaultstyle="true" type="topiclink" href="zenandtheartoffinalization" styleclass="Normal" translate="true">Zen and the Art of Finalization</link><text styleclass="Normal" translate="true"> provides advice.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Any Dolphin object can be marked as requiring finalization, on an instance specific basic, and is then guaranteed to receive a </text><text styleclass="Class Name" translate="true">#finalize</text><text styleclass="Normal" translate="true"> message before it actually dies (i.e. the memory it occupies is freed). The default implementation of </text><text styleclass="Class Name" translate="true">#finalize</text><text styleclass="Normal" translate="true"> (in </text><text styleclass="Normal" translate="true">Object</text><text styleclass="Normal" translate="true">) is to do nothing:</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">finalize</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;&quot;Perform any death-bed operations as the receiver is about to expire. The default</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;is to do nothing.</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;It is not necessary to remove an objects finalization mark, since this has already been</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;done by the garbage collector. Should you wish an object to be finalized again, you</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; must send it #beFinalizable again (this can be done from the #finalize message, but</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; be careful as this may leave the object in an endless loop of finalizations, consuming</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; system </text><link displaytype="text" defaultstyle="true" type="topiclink" href="glossresources" styleclass="Code Example" translate="true">resources</link><text styleclass="Code Example" translate="true">).</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;The receiver will cease to exist at some time after its finalize method has completed (at</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;the very latest at the next GC), unless that method causes additional references to be</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;taken to the receiver. It is a good idea to remove any circular references in an object&apos;s</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;finalize method to shorten its remaining life.</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;Note that this method is only sent to objects which are marked as requiring</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;finalization (see #beFinalizable) when their last strong reference is removed. The</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;object will not receiver the message immediately, but only on the next run of the</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;Finalizer process (which runs at a low priority), and if the object has outstanding</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;weak references, only then after a run of the full garbage collector (which is</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; necessarily a relatively infrequent occurrence).&quot;</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The comment in this method is quite instructive, but we&apos;ll ignore some of the details for now.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The </text><link displaytype="text" defaultstyle="true" type="topiclink" href="finalization" styleclass="Normal" translate="true">Finalization</link><text styleclass="Normal" translate="true"> pattern explains the procedure for implementing finalization in some detail, but in summary:</text></para>
    <list id="3" type="ul" listtype="bullet" formatstring="&#183;" format-charset="SYMBOL_CHARSET" levelreset="true" legalstyle="false" startfrom="1" styleclass="Normal" style="margin-left:24px; font-family:Symbol; font-size:9pt; color:#000000;">
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Send the object the </text><text styleclass="Class Name" translate="true">#beFinalizable</text><text styleclass="Normal" translate="true"> message at some time during its life (probably immediately after acquiring some external resource).</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Implement the </text><text styleclass="Class Name" translate="true">#finalize</text><text styleclass="Normal" translate="true"> message to perform the necessary clean up.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Should you wish to revoke an objects right to finalization, then send it the </text><text styleclass="Class Name" translate="true">#beUnfinalizable</text><text styleclass="Normal" translate="true"> message.</text></li>
    </list>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Having taken these steps you can merrily create objects in the certain knowledge that they will clean up after themselves when they are no longer required, because the </text><text styleclass="Class Name" translate="true">MemoryManager</text><text styleclass="Normal" translate="true"> makes certain guarantees to objects marked as requiring finalization (those it considers to have &quot;last requests&quot;):</text></para>
    <list id="4" type="ul" listtype="bullet" formatstring="&#183;" format-charset="SYMBOL_CHARSET" levelreset="true" legalstyle="false" startfrom="1" styleclass="Normal" style="margin-left:24px; font-family:Symbol; font-size:9pt; color:#000000;">
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Such objects will receive a </text><text styleclass="Class Name" translate="true">#finalize</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">message, at some &quot;interval&quot; after their last reference from an object not marked as weak has been cleared (weak references have no effect on the lifetime of an object). The &quot;interval&quot; in question is of unspecified duration, but would normally be after the next garbage collection cycle (GC).</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Objects with last requests are guaranteed to receive only a single </text><text styleclass="Class Name" translate="true">#finalize</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">message, no matter how many objects weakly reference them.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Objects with last requests will die immediately after they have carried out their last requests, but</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Objects can be rescued in their finalize message simply by taking a further reference to themselves i.e. by assignment into some non-temporary variable. Such rescued objects will not receiver a further </text><text styleclass="Class Name" translate="true">#finalize</text><text styleclass="Normal" translate="true"> message, unless they are sent </text><text styleclass="Class Name" translate="true">#beFinalizable</text><text styleclass="Normal" translate="true"> again.</text></li>
    </list>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The memory manager is careful to ensure that objects queued for finalization remain valid until their finalization is complete (and of course objects can rescue themselves in the </text><text styleclass="Class Name" translate="true">#finalize</text><text styleclass="Normal" translate="true"> method too, although they will have lost all their former weak references), and this can result in some apparent strangeness when finalizable objects reference other finalizable objects. The precise finalization behaviour is defined in </text><link displaytype="text" defaultstyle="true" type="topiclink" href="therules" styleclass="Normal" translate="true">The Rules</link><text styleclass="Normal" translate="true">. It may be important to understand these rules in order to correctly code </text><text styleclass="Class Name" translate="true">#finalize</text><text styleclass="Normal" translate="true"> methods where non-trivial relationships exist between finalizable objects and/or weakly referencing objects, but this is an advanced topic so be warned!.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">It is worth noting that finalization is performed asynchronously by a lower priority process, and this has a number of implications:</text></para>
    <list id="5" type="ul" listtype="bullet" formatstring="&#183;" format-charset="SYMBOL_CHARSET" levelreset="true" legalstyle="false" startfrom="1" styleclass="Normal" style="margin-left:24px; font-family:Symbol; font-size:9pt; color:#000000;">
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Finalization runs at a low priority so that it does not disrupt or delay normal processing.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Finalization may itself be considerably delayed (perhaps indefinitely), and this may significantly extend the life of objects which would otherwise be garbage collectable.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Process synchronisation is not normally necessary because, by definition, an object referenced from another process has no legitimate reason to be lurking in the finalization queue (it has references!). If, however, clean-up operations reference objects which may be in use by other processes, then process synchronization may be required.</text></li>
    </list>
  </body>
</topic>
