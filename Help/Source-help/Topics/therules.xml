<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../helpproject.xsl" ?>
<topic template="Default" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../helpproject.xsd">
  <title translate="true">The Rules</title>
  <keywords>
    <keyword translate="true">The Rules</keyword>
  </keywords>
  <body>
    <header>
      <para styleclass="Heading1"><text styleclass="Heading1" translate="true">The Rules</text></para>
    </header>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The co-ordination and initiation of Finalization and the murdering of Weak References are the responsibility of the memory manager, and are performed during a garbage collection (GC) cycle, according to the following rules (you may want to skip this advanced topic):</text></para>
    <list id="1" type="ol" listtype="decimal" formatstring="&#37;&#48;&#58;&#115;&#46;" levelreset="false" legalstyle="false" startfrom="1" styleclass="Normal" style="margin-left:24px; font-family:Arial; font-size:9pt; color:#000000;">
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Any objects which are directly reachable down a chain of strong references from the &quot;roots of the world&quot; will survive the GC, and will NOT be queued for finalization.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Any objects which are NOT directly reachable by following a chain of strong references from one of the roots of the world, are candidates for finalization during a particular GC cycle.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Any weakly referencing objects which contain finalization candidates identified as above, are candidates for a bereavement notification following the GC cycle, and will have their pointers to those candidates changed to pointers to the corpse object during this GC cycle, regardless of whether those objects are actually queued for finalization during this GC cycle.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Any weakling which has suffered one or more bereavements during a GC cycle which is also a member of a class marked with the mourning special behaviour bit (termed a mourning weakling), will receive an </text><text styleclass="Class Name" translate="true">#elementsExpired</text><text styleclass="Normal" translate="true">: message telling them how many of such losses the garbage collector inflicted on them.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">A bereavement notification candidate will only actually be queued for such a notification if it is a member of a class bearing the mourning special behaviour mark (applied by sending the class </text><text styleclass="Class Name" translate="true">#makeMourner</text><text styleclass="Normal" translate="true">).</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Mourning weaklings queued for bereavement notifications will receive an </text><text styleclass="Class Name" translate="true">#elementsExpired</text><text styleclass="Normal" translate="true">: message before any of the objects they previously referenced has actually been finalized. This ordering is necessary in order that when objects are queued for finalization, they do not have any non-circular references, strong or weak, because a pre-condition for finalization is that an object must be about to expire.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">A mourning weakling which has suffered bereavements during a GC cycle, but which would otherwise be garbage collected itself, is rescued until after it has been sent an </text><text styleclass="Class Name" translate="true">#elementsExpired</text><text styleclass="Normal" translate="true">: message. If such objects still have no references after processing the </text><text styleclass="Class Name" translate="true">#elementsExpired</text><text styleclass="Normal" translate="true">: message, then they will be garbage collected as normal.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">A finalization candidate will only actually be queued for finalization if it bears the finalization mark (applied by sending </text><text styleclass="Class Name" translate="true">#beFinalizable</text><text styleclass="Normal" translate="true">).</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Should a finalization candidate contain other finalizable objects, then even if those contained finalizable objects are only strongly referenced from the original finalization candidate, then they will not be finalized during the current GC cycle, but will instead survive until at least the completion of the containers #finalize (and probably until the next full GC cycle is complete, should they be circularly referenced). This guarantees that when an object is finalized, any objects which it &quot;owns&quot; (directly or indirectly) will not yet have been finalized, and should therefore be in a valid state.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Where a finalizable object, call it A, references another finalizable object, call it B, then B is guaranteed to be finalized before A. Indeed A cannot be finalized until B has been finalized.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Where a circular reference exists between two finalizable objects, then the order in which those objects are actually finalized is undefined (though they will not be finalized in the same cycle). An example of where such a situation might arise is where there is a finalizable parent which strongly references all its children, and those children are finalizable and have a back pointer to the parent. Although conceptually their is a parent-child relationship, there is no way for the memory manager to determine which should be finalized first (indeed it is not necessarily clear). Where this is the case, </text><text styleclass="Class Name" translate="true">#finalize</text><text styleclass="Normal" translate="true"> methods must coded defensively, and not depend on ordering.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Any object in the finalization queue which is not actively being finalized will have no other references in the image.</text></li>
    </list>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">You may be wondering why these complex rules are necessary, why not just finalize every candidate marked as requiring finalization? Well, the rules are designed to ensure that objects queued for finalization remain valid until their finalization is complete. If we simply queued every candidate for finalization, then we could not guarantee that constituent objects had not already been finalized. This would make coding </text><text styleclass="Class Name" translate="true">#finalize</text><text styleclass="Normal" translate="true"> methods horribly complicated and confusing.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Bereavement notifications are not sent to all weaklings by default, because the necessity of rescuing GC&apos;able weak objects to receive the notification can potentially extend the lifetime of large groups of weak objects referenced by other weak objects (e.g. weak tree nodes) due to a &quot;cascading rescue&quot; effect. Cascading rescues significantly degrade the operation of the system because they may prevent garbage weaklings from being collected for many many GC cycles.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The memory manager must ensure that an object does not receive a </text><text styleclass="Class Name" translate="true">#finalize</text><text styleclass="Normal" translate="true"> message until there are no strong references to it (which are not circular), and we need to take account of strong references from objects which are queued for finalization in the same garbage collection cycle. Even if an object to be finalized is only referenced from another object to be finalized in the same cycle, we must delay its finalization until the next cycle, so that parents are finalized before children, otherwise the parent may not be in a valid state during its finalize. It is not acceptable to have the order of finalization depend purely on the ordering the objects are visited during garbage collection.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Where a finalizable object is circularly referenced (perhaps indirectly), we must ensure that it can be garbage collected - so this precludes simply marking any candidates for finalization, and then only actually finalizing those which are unreferenced, because this would mean that circularly referencing finalizable objects (phew!) would never be garbage collected. In fact it is possible that an indirect circular reference could exist between two finalizable objects, and where this is the case there is no general mechanism for deciding which to finalize first, since there is no notion of ownership.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">This complexity is probably one of the reasons that some other Smalltalks do not support finalization of objects directly. They have only weak references and implement finalization with it: Any object which is not directly reachable through a strong pointer chain is garbage collected, and any weak references are &quot;nilled&quot;. The weakly referencing objects which suffer bereavements, are informed, and it is up to them to perform finalization actions on behalf of the objects that they have lost. This is typically achieved by having a copy of the finalizable objects, and using them as &apos;executors&apos;. This approach makes garbage collection simpler, but is inefficient and requires more complex Smalltalk classes to support it. Furthermore, it does not address the finalization ordering problem. If you want to implement such finalization in Dolphin, you do so quite easily using mourning weak objects, because the Dolphin facilities are a superset.</text></para>
  </body>
</topic>
