<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../helpproject.xsl" ?>
<topic template="Default" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../helpproject.xsd">
  <title translate="true">Blocking the User Interface Main Process</title>
  <keywords>
    <keyword translate="true">Blocking the User Interface Main Process</keyword>
  </keywords>
  <body>
    <header>
      <para styleclass="Heading1"><text styleclass="Heading1" translate="true">Blocking the User Interface Main Process</text></para>
    </header>
    <para styleclass="Notes"><text styleclass="Notes" translate="true">Note: if you find the following explanation difficult to understand, don&apos;t worry; it is not necessary to do so in order to use Sockets effectively.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Since the asynchronous function calls that </text><text styleclass="Program Feature" translate="true">Sockets Connection</text><text styleclass="Normal" translate="true"> makes use of, use Windows messages as their callback mechanism, it is important that the main message processing loop in Dolphin always continues to run. In order to guarantee this, if you execute a blocking Socket call in the user interface process (say by evaluating it in a workspace), then another temporary UI process will be started to take over as the first one is blocked. This allows the callback notification messages generated by the WSA calls to continue to be processed. When the operation completes, the blocking semaphore may then be signalled and the original process will be released. Eventually, when the original process runs to completion, it will be terminated and you&apos;ll be left with the same number of basic processes running in the system, it&apos;s just that the UI process will now be a different one.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">We only mention this here, since it can create some slightly strange effects when evaluating blocking calls from within a workspace. You&apos;ll find, if you issue such a call, that it actually appears not to block since the user interface remains alive. This allows you to evaluate more expressions and perform other UI activities before the original call returns.</text></para>
  </body>
</topic>
