<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../helpproject.xsl" ?>
<topic template="Default" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../helpproject.xsd">
  <title translate="true">How do Finalization and Mourning Actually Work?</title>
  <keywords>
    <keyword translate="true">How do Finalization and Mourning Actually Work?</keyword>
  </keywords>
  <body>
    <header>
      <para styleclass="Heading1"><text styleclass="Heading1" translate="true">How do Finalization and Mourning Actually Work?</text></para>
    </header>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The identification and queuing of objects for finalization, and conversion of weak references to corpses, is a by-product of garbage collection (although there are some fairly significant modifications to the garbage collector to enable this &quot;by-product&quot;). The rules by which this process is governed are described below. Precisely when garbage collection is performed (and therefore when objects finally get a chance to carry out their last requests) is a policy decision made by the memory manager (and for the current beta release, this policy is rather simplistic). The memory manager is also responsible for administering last rites (sending </text><text styleclass="Class Name" translate="true">#finalize</text><text styleclass="Normal" translate="true">) and bereavement counselling (sending </text><text styleclass="Class Name" translate="true">#elementsExpired</text><text styleclass="Normal" translate="true">:</text><text styleclass="Normal" translate="true">) for those objects queued by the garbage collector.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The memory manager</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">maintains a pair of processes for each of these tasks, referred to as the </text><text styleclass="Normal" translate="true">Finalizer </text><text styleclass="Normal" translate="true">and the </text><text styleclass="Normal" translate="true">Undertaker</text><text styleclass="Normal" translate="true">. The respective tasks of these two processes are to dequeue objects from the separate finalization and bereavement queues, and send them </text><text styleclass="Class Name" translate="true">#finalize</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">and </text><text styleclass="Class Name" translate="true">#elementsExpired</text><text styleclass="Normal" translate="true">: </text><text styleclass="Normal" translate="true">messages. The main loop of these processes are very simple, for example:</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">finalizerMain</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;&quot;Private - Wait for objects to be queued to the system finalization queue, then attempt</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; to empty that queue. The VM signals the queue semaphore each time it queues a</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; group of objects to the queue so the semaphore&apos;s signal count does not reflect the</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; number of elements waiting in the queue (this is to reduce the asynchronous</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; signalling overhead and to permit user code to force synchronous finalization</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;by directly invoking administerLastRites). Should the finalizer be prematurely</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;terminated by an error occurring in a #finalize or #finalizeElements: method, then it</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;will be restarted the next time the system goes idle, but the semaphores signal count</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; will not be reset, so any waiting objects should get serviced in the near future,</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;assuming Processor time is available.&quot;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;finalizer := Processor activeProcess.</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;finalizer name: &apos;Finalizer&apos;.</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;[finalizer == Processor activeProcess] whileTrue: [</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;lastRequests wait.</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;self administerLastRites]</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Communication between the memory manager&apos;s processes and the VM is achieved by the use of a pair of </text><text styleclass="Normal" translate="true">Semaphores</text><text styleclass="Normal" translate="true"> which the VM signals whenever it places new elements in the queues. The VM only signals each semaphore once, no matter how many items it places in their respective queues, so the processes employ a secondary loop to dequeue objects until the queues are empty, for example:</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">administerLastRites</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;&quot;Private - Dequeue dying objects from the system finalization queue, and send them a</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;#finalize message. Multiple finalization processes are permissible because access to</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;the VM queue is atomic (which is in any case required for synchronisation with the</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;VM&apos;s garbage &#160; &#160; &#160;collection activities). This allows a user Process to synchronously</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;perform finalization at certain points, for example, so that all objects pending</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; finalization are processed before the </text><link displaytype="text" defaultstyle="true" type="topiclink" href="glossimage" styleclass="Code Example" translate="true">image</link><text styleclass="Code Example" translate="true"> is saved. This may be necessary</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;because the Finalizer runs at a very low priority.&quot;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;| dying |</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;[(dying := self dequeueForFinalization) isNil]</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;whileFalse: [dying finalize]</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Objects dequeued for finalization, are not in any special state, so there are no restrictions on the operations which can be performed against them.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The finalizer runs at a priority one level above the base idle priority in order to minimize the impact of finalization on the foreground system processing. This can result in some delay before finalization if intensive processing is underway. However, as the comment in the method states, finalization can be forced at foreground priority at any time by simply sending </text><text styleclass="Class Name" translate="true">#administerLastRites</text><text styleclass="Normal" translate="true"> to the memory manager. For example, this is done when saving the image to ensure that objects requiring finalization are not saved down into the image:</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">onPreSaveImage</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;&quot;Private - Clean up before a snapshot. We perform a compacting garbage collect</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;to minimize the image size, and then move objects queued for finalization.</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;Two garbage collects are performed to ensure that any objects surviving the first</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;GC because they are referenced by objects pending finalization will be collected</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;by the compacting GC. We need to ensure that all objects pending finalization</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;do actually get finalized to ensure that those holding external </text><link displaytype="text" defaultstyle="true" type="topiclink" href="glossresources" styleclass="Code Example" translate="true">resources</link></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;are cleared down, otherwise, when they are later finalized in a new session,</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;their internal state will be invalid (they will contain invalid handles).</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;It is not necessary to inform weak objects of their losses, because the Undertaker</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;runs at a high priority and should interrupt us to perform that task.&quot;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;self</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;collectGarbage;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;administerLastRites</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The undertaker, in contrast, runs at a very high priority (only just below the priority of the timing process which administers </text><text styleclass="Normal" translate="true">Delays</text><text styleclass="Normal" translate="true">). This is necessary because weaklings generally need to repair the damage sustained from the loss of constituents as soon as possible.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The memory manager monitors the state of its finalizer and undertaker whenever the system is about to go idle, and if it finds that either is not ready to run, or is not waiting on the appropriate semaphore, then it starts a new process. This is a defensive operation to try to prevent system melt down if finalization/mourning code either causes an exception, or inappropriately puts the process to sleep.</text></para>
  </body>
</topic>
