<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../helpproject.xsl" ?>
<topic template="Default" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../helpproject.xsd">
  <title translate="true">Virtual Callbacks</title>
  <keywords>
    <keyword translate="true">Virtual Callbacks</keyword>
  </keywords>
  <body>
    <header>
      <para styleclass="Heading1"><text styleclass="Heading1" translate="true">Virtual Callbacks</text></para>
    </header>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">It is also possible to implement virtual callbacks in Dolphin, and this is how OLE COM servers are implemented. It is not necessary to understand the precise details of how the such callbacks are mapped to method invocations against Smalltalk objects, and indeed it rather complex, but a brief overview is provided below. To see how to implement a COM server object in practice take a look at the </text><text styleclass="Program Feature" translate="true">EnumRect</text><text styleclass="Normal" translate="true"> and </text><text styleclass="Program Feature" translate="true">COM Random Stream</text><text styleclass="Normal" translate="true"> samples.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Virtual callbacks are dispatched into the image by the VM sending a </text><text styleclass="Class Name" translate="true">#comCallback:id:subid:withArgumentsAt:</text><text styleclass="Normal" translate="true">cookie </text><text styleclass="Normal" translate="true">message to the </text><text styleclass="Normal" translate="true">Processor </text><text styleclass="Normal" translate="true">object, as described in </text><link displaytype="text" defaultstyle="true" type="topiclink" href="callbackentrypoints" styleclass="Normal" translate="true">Callback Entry Points</link><text styleclass="Normal" translate="true"> above. The Processor locates the appropriate </text><text styleclass="Class Name" translate="true">COMObjectStub</text><text styleclass="Normal" translate="true">, of which there is one per COM server object (usually a </text><text styleclass="Class Name" translate="true">COMInterfaceImp</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">subinstance, though this is not mandatory), and forwards it a </text><text styleclass="Class Name" translate="true">#callback:vfn withArgumentsAt:</text><text styleclass="Normal" translate="true"> message that identifies the particular </text><text styleclass="Class Name" translate="true">COMInterface</text><text styleclass="Normal" translate="true">, </text><text styleclass="Normal" translate="true">the member function of that interface which is being called, and the address on the machine stack of the arguments accompanying the call. The </text><text styleclass="Class Name" translate="true">COMObjectStub</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">then forwards on the message to the relevant </text><text styleclass="Class Name" translate="true">COMInterface</text><text styleclass="Normal" translate="true">, which in turn forwards it as the appropriate method invocation, usually to the COM server object, although the basic </text><text styleclass="Class Name" translate="true">IUnknown</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">methods are implemented by the stub itself. This rather tortuous route allows each of the objects involved to override the default handling, and allows for a great deal of flexibility in determining which object actually implements a COM method.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">In order to construct the actual method invocation message, the </text><text styleclass="Class Name" translate="true">COMInterface</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">uses its function table. The function table includes object which describe each of the methods in the interface and how they should be dispatched. The function table is constructed by the </text><text styleclass="Class Name" translate="true">#defineFunctions</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">method, which is normally auto-generated by the Active-X component wizard. The function objects include descriptions of the types of the arguments to be found on the machine stack, and this external type information is used to construct Smalltalk objects from the arguments passed on the machine stack. With the argument objects constructed the message is eventually delivered to the target COM server object by performing the selector associated with the function object.</text></para>
  </body>
</topic>
