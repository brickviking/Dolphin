<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../helpproject.xsl" ?>
<topic template="Default" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../helpproject.xsd">
  <title translate="true">Virtual Calls (C++/OLE COM Interface)</title>
  <keywords>
    <keyword translate="true">Virtual Calls (C++/OLE COM Interface)</keyword>
  </keywords>
  <body>
    <header>
      <para styleclass="Heading1"><text styleclass="Heading1" translate="true">Virtual Calls (C++/OLE COM Interface)</text></para>
    </header>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Dolphin can interface directly to objects that obey the C++ virtual calling convention. Obviously this includes C++ objects themselves, but can also include objects implemented in other languages that implement the Microsoft Common Object Model (the basis of OLE), since this is based on the C++ virtual function model. The implementation of such external objects would normally reside in a DLL, or DLLs (under Win32™ there are no special prologs and epilogs for exported functions, so it is always possible to generate a DLL from a class library supplied as a LIB). OLE COM objects can also reside in other executables, and, in the case of Distributed COM, can even reside on remote machines.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">In order to interface to C++ objects there needs to be some way to instantiate such objects (or gain access to those which already exist), and then to invoke those objects member functions. These are some of the fundamental features of COM, but we consider the simpler case of interfacing to C++ in DLLs here. We need a Smalltalk class (or classes) to represent those objects in Smalltalk (i.e. to act as a proxy).</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">For example we might have the simple C++ class:</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">class CPPBlah</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">{</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;char* m_szName;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">public:</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;CBlah(const char* szName) { m_szName = strdup(szName); }</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;virtual ~CPPBlah() { delete m_szName; }</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;virtual const char* getName() { return m_szName; }</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;void setName(const char* szName)</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;{ delete m_szName; m_szName = strdup(szName); }</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">};</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">We might have an </text><text styleclass="Class Name" translate="true">ExternalAddress</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">object pointing at an instance of the C++ class </text><text styleclass="Class Name" translate="true">CPPBlah</text><text styleclass="Normal" translate="true">, i.e. the object lives outside the Smalltalk object space, or we might want the C++ object to reside in Smalltalk memory. These are precisely the capabilities of </text><link displaytype="text" defaultstyle="true" type="topiclink" href="externalstructure" styleclass="Normal" translate="true">ExternalStructure</link><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">(which can represent a structure by value or reference), so we could add a subclass called, say, </text><text styleclass="Class Name" translate="true">ExternalBlah</text><text styleclass="Normal" translate="true">.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Instantiating C++ objects is achieved by calling either a static member function, or an ordinary dynamic link library function. There is no difference, except that the former is likely to have a long mangled name. At present one must determine the mangled name of the function yourself (e.g. by using </text><text styleclass="Normal" translate="true">&quot;dumpbin /exports&quot; </text><text styleclass="Normal" translate="true">or the linker map file). For example we might have a simple factory function (which could be an exported static member of </text><text styleclass="Class Name" translate="true">CPPBlah</text><text styleclass="Normal" translate="true">):</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">__declspec(dllexport) CPPBlah* __stdcall makeNewBlah(const char* szName)</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">{</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;return new CPPBlah(szName);</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">}</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">We could write a method of an </text><text styleclass="Class Name" translate="true">ExternalLibrary</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">subclass, </text><text styleclass="Class Name" translate="true">BlahLibrary</text><text styleclass="Normal" translate="true">, to invoke this factory function thus:</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">makeNewBlah: aString</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;&quot;Answer a new external C++ Blah object.&quot;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;&lt;stdcall: Blah* &apos;_makeNewBlah@4&apos; lpstr&gt;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;^self invalidCall</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">If we then evaluate the following expression</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">BlahLibrary default makeNewBlah: &apos;I&apos;m a new Blah created from Dolphin&apos;</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">We would have an instance of </text><text styleclass="Class Name" translate="true">ExternalBlah</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">containing an </text><text styleclass="Class Name" translate="true">ExternalAddress</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">object pointing at an instance of the C++ class </text><text styleclass="Class Name" translate="true">CPPBlah</text><text styleclass="Normal" translate="true">. Alternatively we could instantiate an </text><text styleclass="Class Name" translate="true">ExternalBlah</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">object, and pass that to a library function which constructs a C++ object in that memory (either by calling the constructor directly, or by using the placement syntax of operator new())</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Our </text><text styleclass="Class Name" translate="true">ExternalStructure</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">subclass, </text><text styleclass="Class Name" translate="true">ExternalBlah</text><text styleclass="Normal" translate="true">, is the home for the virtual call methods. We can add additional Smalltalk instance variables to this class as required.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Once we have an object of the appropriate type, then we want to be able to invoke its member functions. These can be either statically bound, or dynamically bound (virtual). The latter are somewhat easier to implement and call, using the same format as an external library call, but with a virtual prefix and specifying a virtual function number (index in the vtbl) instead of a function name or ordinal. Knowledge of the mangled function name is not required, because the function is accessed by offset into the virtual table (this does mean it is very important to get the offset correct, hence this is calculated automatically in the COM add-in package, which generates all external function definitions automatically). We might define the </text><text styleclass="Class Name" translate="true">CPPBlah::getName()</text><text styleclass="Normal" translate="true"> virtual function as follows:</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">name</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;&quot;Answer a the name of the external C++ Blah object.&quot;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;&lt;virtual cdecl: lpstr 1&gt;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; ^self invalidCall</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The </text><text styleclass="Class Name" translate="true">#name</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">message can then be sent to instances of </text><text styleclass="Class Name" translate="true">ExternalBlah</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">in the normal way and will answer a string which is a </text><text styleclass="Normal" translate="true">copy </text><text styleclass="Normal" translate="true">of that stored in the referenced C++ object.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Normal (non-virtual) member functions may be supported in future by implementing them in the relevant </text><text styleclass="Class Name" translate="true">ExternalLibrary</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">subclass using the </text><text styleclass="Class Name" translate="true">thiscall</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">calling convention. For example:</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">setName: anExternalObject to: aString</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;&quot;Set the name of an external C++ Blah object.&quot;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;&lt;thiscall: void &apos;_mangle_mangle_setName_mangle@8&apos; lpvoid lpstr&gt;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;^self invalidCall</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">At present, however, </text><text styleclass="Class Name" translate="true">thiscall</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">is not supported (primarily because it is not needed for OLE, as all COM functions must be virtual). The workaround is to ensure that all C++ member functions one might wish to call from Dolphin are declared as virtual, or explicitly declared as with </text><text styleclass="Class Name" translate="true">cdecl</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">or </text><text styleclass="Class Name" translate="true">stdcall</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">calling conventions.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Ordinary member functions will have to be added to an </text><text styleclass="Class Name" translate="true">ExternalLibrary</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">rather than the C++ object&apos;s proxy Smalltalk class, because Dolphin needs to be able to locate the functions using </text><text styleclass="Class Name" translate="true">GetProcAddress</text><text styleclass="Normal" translate="true">()</text><text styleclass="Normal" translate="true"> (for this reason they must also be exported). Furthermore it is necessary to explicitly pass the implicit (in C++) </text><text styleclass="Normal" translate="true">this </text><text styleclass="Normal" translate="true">parameter (being the address from the relevant proxy object). This does make using ordinary member functions considerably less convenient. To mitigate this inconvenience it is suggested that forwarding methods are implemented in the proxy class itself to </text><text styleclass="Normal" translate="true">wrap the external calls.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Static member functions are called in exactly the same way as any other exported dynamic link library functions.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">It is suggested that Dolphin&apos;s finalization support (see </text><link displaytype="text" defaultstyle="true" type="topiclink" href="weakreferencesandfinalization" styleclass="Normal" translate="true">Weak References and Finalization</link><text styleclass="Normal" translate="true">) be used to give the proxy object (e.g. the </text><text styleclass="Class Name" translate="true">ExternalBlah</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">instance) a chance to invoke the C++ destructor when the object has no further Smalltalk references. This makes it much easier to synchronize the lifetime of the heap based C++ object with the garbage collected Smalltalk object. We recommend that destructors are always declared as virtual, as this makes it possible to correctly delete a C++ object polymorphically, and, as mentioned, makes it easier to call in a DLL (e.g. from Dolphin).</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">There is some flexibility over the definition of the proxy class. The virtual call primitive is able to invoke C++ virtual functions against such a class of objects if:</text></para>
    <list id="1" type="ul" listtype="bullet" formatstring="&#183;" format-charset="SYMBOL_CHARSET" levelreset="true" legalstyle="false" startfrom="1" styleclass="Normal" style="margin-left:24px; font-family:Symbol; font-size:9pt; color:#000000;">
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">It is a byte object of at least 4 bytes. In this case the primitive assumes that it is the object itself - i.e. the C++ object lives in the Smalltalk memory space.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">It is an indirection byte object (i.e. a pointer). </text><text styleclass="Class Name" translate="true">ExternalAddress</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">is an example of such a class. In this case the primitive assumes that the objects state is a pointer to the C++ object, which probably lives outside the Smalltalk memory space (i.e. it contains the this pointer). It is not necessary to subclass </text><text styleclass="Class Name" translate="true">ExternalAddress</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">to define an indirection class, but see that class to see how to do it. </text><text styleclass="Class Name" translate="true">lpvoid</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">return types can be mutated to correctly defined indirection classes by using</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Class Name" translate="true">#becomeA</text><text styleclass="Normal" translate="true">:</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">It is a pointer object whose first instance variable is as described in (1) or (2), e.g. subclasses of </text><text styleclass="Class Name" translate="true">ExternalStructure</text><text styleclass="Normal" translate="true">. This is generally the most powerful and flexible solution.</text></li>
    </list>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Normally it is most convenient to add the proxy class as a subclass of </text><text styleclass="Class Name" translate="true">ExternalStructure</text><text styleclass="Normal" translate="true">.</text></para>
  </body>
</topic>
