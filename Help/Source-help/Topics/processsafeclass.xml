<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../helpproject.xsl" ?>
<topic template="Default" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../helpproject.xsd">
  <title translate="true">Process Safe Class</title>
  <keywords>
    <keyword translate="true">Process Safe Class</keyword>
  </keywords>
  <body>
    <header>
      <para styleclass="Heading1"><text styleclass="Heading1" translate="true">Process Safe Class</text></para>
    </header>
    <para styleclass="Normal Head"><text styleclass="Normal Head" translate="true">Context</text></para>
    <para styleclass="Normal Head"><text styleclass="Normal" translate="true">You are creating a </text><link displaytype="text" defaultstyle="true" type="topiclink" href="newclass" styleclass="Normal" translate="true">New Class</link><text styleclass="Normal" translate="true"> and are aware that some instances of this class will need to be shared between multiple independent Smalltalk processes. In such cases, the class must be protected so that attempts to mutate an instance from one process do not impinge on the attempts to access or mutate the instance from other processes. How do we control and synchronize access to the state of the instances so that corruption does not occur?</text></para>
    <para styleclass="Normal Head"><text styleclass="Normal Head" translate="true">Solution</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Create a </text><text styleclass="Program Feature" translate="true">Process Safe Class</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">that contains a mutex to control access to the critical state of the classes instances. Step by step instructions are as follows:</text></para>
    <list id="4" type="ol" listtype="decimal" formatstring="&#37;&#48;&#58;&#115;&#46;" levelreset="true" legalstyle="false" startfrom="1" styleclass="Normal" style="font-family:Arial; font-size:9pt; color:#000000;">
      <li styleclass="Normal"><text styleclass="Normal" translate="true">Create a suitable </text><link displaytype="text" defaultstyle="true" type="topiclink" href="weakcollection" styleclass="Normal" translate="true">New Class</link><text styleclass="Normal" translate="true"> and ensure that it is a pointer object (not byte object) class. If a process safe byte object is required, implement a wrapper class containing the byte object as an instance variable (see </text><link displaytype="text" defaultstyle="true" type="topiclink" href="inheritancevs.composition" styleclass="Normal" translate="true">Inheritance vs Composition</link><text styleclass="Normal" translate="true">).</text></li>
      <li styleclass="Normal"><text styleclass="Normal" translate="true">Add an instance variable, </text><text styleclass="Normal" translate="true">mutex</text><text styleclass="Normal" translate="true">, to hold the process synchronization object and during Instance Initialization assign a new instance of </text><text styleclass="Class Name" translate="true">Mutex</text><text styleclass="Normal" translate="true"> to this variable. A </text><text styleclass="Class Name" translate="true">Mutex</text><text styleclass="Normal" translate="true"> is preferable to a </text><text styleclass="Class Name" translate="true">Semaphore</text><text styleclass="Normal" translate="true"> because it permits multiple entries to a critical section from the same process, while excluding only other processes. This means that you not have to worry about a single process deadlocking itself.</text></li>
      <li styleclass="Normal"><text styleclass="Normal" translate="true">All the superclass methods that provide access to the shared state must be overridden to perform a supersend of the same message to the superclass but inside a critical section guarded by the mutex.</text></li>
    </list>
    <list id="5" type="ul" listtype="bullet" formatstring="&#183;" format-charset="SYMBOL_CHARSET" levelreset="true" legalstyle="false" startfrom="1" styleclass="Normal" style="margin-left:24px; font-family:Symbol; font-size:9pt; color:#000000;">
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">One way of doing this neatly is to selectively override private superclass methods which are used as accessors by the class&apos;s public methods. Protecting these private accessors may make protecting a number of public methods unnecessary.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">Override all public superclass methods which directly access the shared data of the superclass where those methods are not made process safe by the above.</text></li>
      <li styleclass="Normal" style="margin-left:24px;"><text styleclass="Normal" translate="true">If a particular method involves a number of operations which should be carried out indivisibly, then that method must be overridden and protected by the mutex, regardless of whether the implementation uses protected private methods.</text></li>
    </list>
    <list id="6" type="ol" listtype="decimal" formatstring="&#37;&#48;&#58;&#115;&#46;" levelreset="true" legalstyle="false" startfrom="4" styleclass="Normal" style="font-family:Arial; font-size:9pt; color:#000000;">
      <li styleclass="Normal"><text styleclass="Normal" translate="true">Don&apos;t forget to protect methods inherited from the superclass&apos; superclass, and so on.</text></li>
    </list>
    <para styleclass="Normal Head"><text styleclass="Normal Head" translate="true">Known Uses</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">A relatively simple example in the base system is </text><text styleclass="Class Name" translate="true">SharedSet</text><text styleclass="Normal" translate="true"> (a process safe subclass of </text><text styleclass="Normal" translate="true">Set</text><text styleclass="Normal" translate="true">). New </text><text styleclass="Class Name" translate="true">SharedSets</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">are initialized as follows:</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">initialize</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;&quot;Instance variable initialization. The mutex protects against concurrent access from multiple</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;processes, but permits the same process to make multiple entries.&quot;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;super initialize.</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;mutex := Mutex new</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">The </text><text styleclass="Class Name" translate="true">Set&gt;&gt;add:</text><text styleclass="Normal" translate="true"> method is overridden as follows:</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">add: newObject</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;&quot;Include newObject as one of the elements of the receiver. Answer newObject.&quot;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;^mutex critical: [super add: newObject]</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Note that the value of the critical section is the value of the expression inside the block, so there is no need to perform a ^-return inside the critical section and cause an unwind to be set in motion.</text></para>
    <para styleclass="Normal"><text styleclass="Class Name" translate="true">#do</text><text styleclass="Normal" translate="true">:</text><text styleclass="Normal" translate="true"> is overridden in a similar manner:</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">do: operation</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;&quot;Evaluate monadic value argument, operation, for each of the</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;elements (non-nil members) of the receiver. Answers the receiver.&quot;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;mutex critical: [super do: operation]</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Class Name" translate="true">SharedSet</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">conservatively overrides </text><text styleclass="Class Name" translate="true">#asArray</text><text styleclass="Normal" translate="true"> as follows:</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">asArray</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;&quot;Answer an Array whose elements are those of the receiver</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;(ordering is possibly arbitrary). Must implement as critical section</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;as otherwise Array size might be wrong.&quot;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;^mutex critical: [super asArray]</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">This is apparently protected by the overridden </text><text styleclass="Class Name" translate="true">#do</text><text styleclass="Normal" translate="true">:</text><text styleclass="Normal" translate="true"> method, but the size of the array could turn out to be wrong if resized by another process during the execution of </text><text styleclass="Class Name" translate="true">Collection&gt;&gt;asArray</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">(below) between the point where the size of the </text><text styleclass="Class Name" translate="true">SharedSet</text><text styleclass="Normal" translate="true">&#32;</text><text styleclass="Normal" translate="true">is taken, and the </text><text styleclass="Class Name" translate="true">#do</text><text styleclass="Normal" translate="true">:</text><text styleclass="Normal" translate="true"> message being sent.</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">asArray</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;&quot;Answer an Array whose elements are those of the receiver.</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;(ordering is that of the #do: operation as implemented by the receiver).&quot;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;| anArray i |</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;anArray := Array new: self size.</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;i := 1.</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;self do: [:e |</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;anArray at: i put: e.</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;i := i + 1].</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;^anArray</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">To avoid the possibility of a client supplied &quot;if absent&quot; block raising an exception inside a critical section, </text><text styleclass="Class Name" translate="true">SharedSet&gt;&gt;remove:ifAbsent:</text><text styleclass="Normal" translate="true"> makes use of a unique object (or cookie) to identify the &quot;not found&quot; case, and then evaluates the client supplied exception handler when the cookie is detected, as follows:</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true">remove: oldElement ifAbsent: exceptionHandler</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;&quot;If oldElement is one of the receiver&apos;s elements, then remove it from the</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;receiver and answer it (as Sets cannot contain duplicates, only one element is</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;ever removed). If oldElement is not an element of the receiver (i.e.</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;no element of the receiver is #= to oldObject) then answer the</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;result of evaluating the niladic valuable, exceptionHandler.&quot;</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;| answer |</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;answer := mutex critical: [super remove: oldElement ifAbsent: [AbsentCookie]].</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160;^answer == AbsentCookie</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;ifTrue: [exceptionHandler value]</text></para>
    <para styleclass="Code Example"><text styleclass="Code Example" translate="true"> &#160; &#160; &#160; &#160;ifFalse: [answer]</text></para>
    <para styleclass="Code Example"></para>
    <para styleclass="Normal"><text styleclass="Class Name" translate="true">SharedSet</text><text styleclass="Normal" translate="true"> overrides other methods as necessary - see the documentation method </text><text styleclass="Class Name" translate="true">#overrideStrategy</text><text styleclass="Normal" translate="true"> for explanation of why certain methods are overridden, and others not.</text></para>
    <para styleclass="Normal"><text styleclass="Normal" translate="true">Most </text><link displaytype="text" defaultstyle="true" type="topiclink" href="weakcollection" styleclass="Normal" translate="true">Weak Collections</link><text styleclass="Normal" translate="true"> are subclasses of process safe classes (e.g. </text><text styleclass="Class Name" translate="true">WeakLookupTable</text><text styleclass="Normal" translate="true"> is a subclass of </text><text styleclass="Class Name" translate="true">SharedLookupTable</text><text styleclass="Normal" translate="true">).</text></para>
    <para styleclass="Normal Head"><text styleclass="Normal Head" translate="true">Forces</text></para>
    <list id="7" type="ul" listtype="bullet" formatstring="&#183;" format-charset="SYMBOL_CHARSET" levelreset="true" legalstyle="false" startfrom="1" styleclass="Normal" style="font-family:Symbol; font-size:9pt; color:#000000;">
      <li styleclass="Normal"><text styleclass="Normal" translate="true">If your requirements are met by an existing shared collection, then it is easier to make use of those by containment rather than creating your own new process safe subclass.</text></li>
      <li styleclass="Normal"><text styleclass="Normal" translate="true">Tracking down bugs resulting from process synchronization problems can be very difficult, so it is better to be cautious, and protect too much rather than too little.</text></li>
      <li styleclass="Normal"><text styleclass="Normal" translate="true">Process safety must be maintained in the presence of future changes, so spare some thought to the ease with which future maintenance can be carried out.</text></li>
      <li styleclass="Normal"><text styleclass="Normal" translate="true">The objective is to achieve mutually exclusive access to the shared state of the object; don&apos;t try to be too clever.</text></li>
      <li styleclass="Normal"><text styleclass="Normal" translate="true">Performing explicit ^-returns and raising exceptions from inside the critical section is possible, but incurs some unwind overhead to ensure that the mutex is unlocked, and will also increase the chance of a deadlock occurring.</text></li>
    </list>
    <para styleclass="Normal Head"><text styleclass="Normal Head" translate="true">Related Patterns</text></para>
    <para styleclass="Normal"><link displaytype="text" defaultstyle="true" type="topiclink" href="newclass" styleclass="Normal" translate="true">New Class</link><text styleclass="Normal" translate="true">, </text><link displaytype="text" defaultstyle="true" type="topiclink" href="inheritancevs.composition" styleclass="Normal" translate="true">Inheritance vs Composition</link><text styleclass="Normal" translate="true">, </text><link displaytype="text" defaultstyle="true" type="topiclink" href="weakcollection" styleclass="Normal" translate="true">Weak Collection</link></para>
  </body>
</topic>
